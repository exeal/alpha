#!/usr/local/bin/perl

# gen-uax29-test.pl (c) 2007 exeal
#
# This script generates C++ code for tests about concrete break iterators
# implement ascension.unicode.BreakIterator. See ascension/test/break-iterator-test.cpp.
#
# This takes three input files obtained from Unicode.org:
# - GraphemeBreakTest.txt
# - WordBreakTest.txt
# - SentenceBreakTest.txt
# in UNIDATA/auxiliary/.

use strict;
use integer;
use IO::File;

my $out = new IO::File('> break-iterator-test.cpp');
die "can't open output file: break-iterator-test.cpp\n" unless(defined($out));

sub handleFile($$) {
	my ($fileName, $postfix) = @_;
	my $in = new IO::File('< ' . $fileName);
	die("can't open: $fileName\n") if(!defined($in));
	my $lastIndices = '';
	while(<$in>) {
		next unless(m/^รท[^\#]+/);
		$_ = $&;
		my ($i, $charIndex, $text) = (0, 0, '');
		my @indices;
		while(/(รท|ร)\s([\dA-F]+)/g) {
			$text .= '\x' . $2;
			push(@indices, $charIndex) if($1 eq 'รท');
			++$charIndex;
		}
		push(@indices, $charIndex);
		if(join(', ', @indices) ne $lastIndices) {
			print $out "\t" . 'initializeContainer(indices) = ' . join(', ', @indices) . ";\n";
			$lastIndices = join(', ', @indices);
		}
		print $out "\tcheck$postfix(L\"$text\", indices);\n";
	}
}

die "usage: gen-uax29-test.pl [input-file-directory]\n" if($#ARGV > 0 or $ARGV[0] eq '-h');
my $directory = shift @ARGV;
if($directory ne '') {
	$directory =~ s/\//\\/;
	$directory .= '\\' unless($directory =~ /\\$/);
}

print $out '// automatically generated by `perl gen-uax29-test.pl` at $ ' . scalar(localtime) . " \$\n\n";
print $out <<'HEAD';
// break-iterator-test.cpp
#include "stdafx.h"
#include "../break-iterator.hpp"

namespace {
	template<template<class> class Iterator>
	void check(Iterator<ascension::unicode::CStringCharacterIterator>& i, const std::vector<std::size_t>& indices) {
		const ascension::Char* const p = i.base().tell();
		// forward iteration
		for(std::vector<std::size_t>::const_iterator j = indices.begin(); j != indices.end(); ++j)
			BOOST_CHECK_EQUAL((i++).base().tell(), p + *j);
		// backward iteration
		BOOST_REQUIRE(i.base().isLast());
		for(std::vector<std::size_t>::const_reverse_iterator j = indices.rbegin(); j != indices.rend(); ++j)
			BOOST_CHECK_EQUAL((i--).base().tell(), p + *j);
		// random check
		BOOST_REQUIRE(i.base().isFirst());
		for(std::vector<std::size_t>::const_iterator j = indices.begin(); j != indices.end(); ++j)
			BOOST_CHECK(i.isBoundary(ascension::unicode::CStringCharacterIterator(p + *j, p, i.base().getLast())));
	}

	inline void checkGBI(const ascension::String& s, const std::vector<std::size_t>& indices) {
		ascension::unicode::CStringCharacterIterator text(s.data(), s.data(), s.data() + s.length());
		return check<ascension::unicode::GraphemeBreakIterator>(
			ascension::unicode::GraphemeBreakIterator<ascension::unicode::CStringCharacterIterator>(text), indices);
	}

	inline void checkWBI(const ascension::String& s, const std::vector<std::size_t>& indices) {
		ascension::unicode::CStringCharacterIterator text(s.data(), s.data(), s.data() + s.length());
		return check<ascension::unicode::WordBreakIterator>(
			ascension::unicode::WordBreakIterator<ascension::unicode::CStringCharacterIterator>(
				text, ascension::unicode::BOUNDARY_OF_SEGMENT, ascension::unicode::CharacterDetector()), indices);
	}
}
HEAD

print $out "\nvoid testGraphemeBreakIterator() {\n\tstd::vector<std::size_t> indices;\n";
handleFile($directory . 'GraphemeBreakTest.txt', 'GBI');
print $out "}\n\nvoid testWordBreakIterator() {\n\tstd::vector<std::size_t> indices;\n";
handleFile($directory . 'WordBreakTest.txt', 'WBI');
print $out "}\n\nvoid testSentenceBreakIterator() {\n\tstd::vector<std::size_t> indices;\n";
handleFile($directory . 'SentenceBreakTest.txt', 'SBI');
print $out "}\n";
